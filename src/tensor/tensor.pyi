"""
Tensor math library
"""
from __future__ import annotations
import collections.abc
import typing
__all__: list[str] = ['CPU', 'MODE', 'Matrix', 'OPENCL', 'PLATFORM', 'Scalar', 'Tensor3', 'Vector', 'init']
class Matrix:
    @typing.overload
    def __add__(self, arg0: Matrix) -> Matrix:
        ...
    @typing.overload
    def __add__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    @typing.overload
    def __iadd__(self, arg0: Matrix) -> Matrix:
        ...
    @typing.overload
    def __iadd__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    @typing.overload
    def __imul__(self, arg0: Matrix) -> Matrix:
        ...
    @typing.overload
    def __imul__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(2)"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(2)"], arg1: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(2)"], arg1: collections.abc.Sequence[typing.SupportsFloat]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(2)"], arg1: typing.SupportsFloat, arg2: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __isub__(self, arg0: Matrix) -> Matrix:
        ...
    @typing.overload
    def __isub__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    def __itruediv__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    def __matmul__(self, arg0: Matrix) -> Matrix:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix) -> Matrix:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    def __neg__(self) -> Matrix:
        ...
    def __pos__(self) -> Matrix:
        ...
    def __radd__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    def __rsub__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    @typing.overload
    def __sub__(self, arg0: Matrix) -> Matrix:
        ...
    @typing.overload
    def __sub__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    def __truediv__(self, arg0: typing.SupportsFloat) -> Matrix:
        ...
    def get_axes(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    def get_shape(self) -> typing.Annotated[list[int], "FixedSize(2)"]:
        ...
    def get_size(self) -> int:
        ...
    def t(self) -> Matrix:
        ...
    @typing.overload
    def transpose(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(2)"]) -> Matrix:
        ...
    @typing.overload
    def transpose(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> Matrix:
        ...
class PLATFORM:
    """
    Members:
    
      CPU
    
      OPENCL
    """
    CPU: typing.ClassVar[PLATFORM]  # value = <PLATFORM.CPU: 0>
    OPENCL: typing.ClassVar[PLATFORM]  # value = <PLATFORM.OPENCL: 1>
    __members__: typing.ClassVar[dict[str, PLATFORM]]  # value = {'CPU': <PLATFORM.CPU: 0>, 'OPENCL': <PLATFORM.OPENCL: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Scalar:
    @typing.overload
    def __add__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __add__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    @typing.overload
    def __iadd__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __iadd__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    @typing.overload
    def __imul__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __imul__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(0)"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(0)"], arg1: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(0)"], arg1: collections.abc.Sequence[typing.SupportsFloat]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(0)"], arg1: typing.SupportsFloat, arg2: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __isub__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __isub__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    def __itruediv__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    @typing.overload
    def __mul__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    def __neg__(self) -> Scalar:
        ...
    def __pos__(self) -> Scalar:
        ...
    def __radd__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    def __rsub__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    @typing.overload
    def __sub__(self, arg0: Scalar) -> Scalar:
        ...
    @typing.overload
    def __sub__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    def __truediv__(self, arg0: typing.SupportsFloat) -> Scalar:
        ...
    def get_axes(self) -> typing.Annotated[list[int], "FixedSize(0)"]:
        ...
    def get_shape(self) -> typing.Annotated[list[int], "FixedSize(0)"]:
        ...
    def get_size(self) -> int:
        ...
class Tensor3:
    @typing.overload
    def __add__(self, arg0: Tensor3) -> Tensor3:
        ...
    @typing.overload
    def __add__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    @typing.overload
    def __iadd__(self, arg0: Tensor3) -> Tensor3:
        ...
    @typing.overload
    def __iadd__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    @typing.overload
    def __imul__(self, arg0: Tensor3) -> Tensor3:
        ...
    @typing.overload
    def __imul__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], arg1: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], arg1: collections.abc.Sequence[typing.SupportsFloat]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"], arg1: typing.SupportsFloat, arg2: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __isub__(self, arg0: Tensor3) -> Tensor3:
        ...
    @typing.overload
    def __isub__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    def __itruediv__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    @typing.overload
    def __mul__(self, arg0: Tensor3) -> Tensor3:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    def __neg__(self) -> Tensor3:
        ...
    def __pos__(self) -> Tensor3:
        ...
    def __radd__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    def __rsub__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    @typing.overload
    def __sub__(self, arg0: Tensor3) -> Tensor3:
        ...
    @typing.overload
    def __sub__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    def __truediv__(self, arg0: typing.SupportsFloat) -> Tensor3:
        ...
    def get_axes(self) -> typing.Annotated[list[int], "FixedSize(3)"]:
        ...
    def get_shape(self) -> typing.Annotated[list[int], "FixedSize(3)"]:
        ...
    def get_size(self) -> int:
        ...
    def t(self) -> Tensor3:
        ...
    @typing.overload
    def transpose(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(3)"]) -> Tensor3:
        ...
    @typing.overload
    def transpose(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> Tensor3:
        ...
class Vector:
    @typing.overload
    def __add__(self, arg0: Vector) -> Vector:
        ...
    @typing.overload
    def __add__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    @typing.overload
    def __iadd__(self, arg0: Vector) -> Vector:
        ...
    @typing.overload
    def __iadd__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    @typing.overload
    def __imul__(self, arg0: Vector) -> Vector:
        ...
    @typing.overload
    def __imul__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(1)"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(1)"], arg1: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(1)"], arg1: collections.abc.Sequence[typing.SupportsFloat]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsInt], "FixedSize(1)"], arg1: typing.SupportsFloat, arg2: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __isub__(self, arg0: Vector) -> Vector:
        ...
    @typing.overload
    def __isub__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    def __itruediv__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    @typing.overload
    def __mul__(self, arg0: Vector) -> Vector:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    def __neg__(self) -> Vector:
        ...
    def __pos__(self) -> Vector:
        ...
    def __radd__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    def __rsub__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    @typing.overload
    def __sub__(self, arg0: Vector) -> Vector:
        ...
    @typing.overload
    def __sub__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    def __truediv__(self, arg0: typing.SupportsFloat) -> Vector:
        ...
    def get_axes(self) -> typing.Annotated[list[int], "FixedSize(1)"]:
        ...
    def get_shape(self) -> typing.Annotated[list[int], "FixedSize(1)"]:
        ...
    def get_size(self) -> int:
        ...
def init(arg0: str) -> None:
    ...
CPU: PLATFORM  # value = <PLATFORM.CPU: 0>
MODE: PLATFORM  # value = <PLATFORM.OPENCL: 1>
OPENCL: PLATFORM  # value = <PLATFORM.OPENCL: 1>
